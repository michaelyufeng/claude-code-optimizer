---
description: Automatic model selection based on task complexity and type for optimal token usage
---

# 模型自动选择

根据任务复杂度和类型自动选择最优模型，优化 Token 使用和成本。

## 核心理念

```
简单任务 → Haiku   (快速 + 低成本)
常规任务 → Sonnet  (平衡)
关键任务 → Opus    (最强能力)
```

**目标**: 在保证质量的前提下，最小化 Token 消耗和成本。

---

## 三层选择策略

### 层级 1: 阶段级别（基础模型）

每个阶段有默认推荐模型：

| 阶段 | Agent | 默认模型 | 原因 |
|------|-------|----------|------|
| 🔬 研究 | 分析师 | Sonnet | 需要分析和理解能力 |
| 📋 规划 | PM | Sonnet | 需要规划和组织能力 |
| 🏗️ 架构 | 架构师 | **Opus** | 关键架构决策 |
| 💻 开发 | 开发者 | **动态** | 根据任务自动选择 |
| 🧪 测试 | 测试员 | Sonnet | 需要理解代码逻辑 |
| 🚀 部署 | 运维 | Sonnet | 配置和脚本编写 |

### 层级 2: 任务规模（动态调整）

开发阶段根据任务规模自动选择：

| 规模 | 代码行数 | 文件数 | 选择模型 | 相对成本 |
|------|----------|--------|----------|----------|
| S (小) | <50 | 1 | **Haiku** | $ |
| M (中) | 50-200 | 1-3 | Sonnet | $$ |
| L (大) | 200-500 | 3-5 | Sonnet | $$ |
| XL (超大) | >500 | >5 | **Opus** | $$$ |

**自动估算标准:**
- 预估代码行数（基于需求描述）
- 涉及文件数量
- 功能复杂度评分

### 层级 3: 任务类型（最高优先级）

特定任务类型强制使用特定模型：

| 任务类型 | 强制模型 | 原因 | 示例 |
|----------|----------|------|------|
| 简单查询 | Haiku | 快速响应 | 查看状态、列出文件 |
| 格式转换 | Haiku | 模式化操作 | JSON 转换、格式化 |
| 日志分析 | Haiku | 数据提取 | 错误日志分析 |
| 基础代码生成 | Haiku | 模板化代码 | CRUD 接口 |
| 复杂编码 | Sonnet | 需要上下文理解 | 业务逻辑实现 |
| 代码审查 | Sonnet | 需要判断能力 | Code Review |
| API 设计 | Sonnet | 需要设计能力 | RESTful API |
| **架构决策** | **Opus** | 关键决策 | 技术选型、系统设计 |
| **安全审计** | **Opus** | 关键任务 | 漏洞扫描、安全评估 |
| **复杂问题解决** | **Opus** | 需要深度思考 | 性能优化、疑难 Bug |

---

## 选择算法

```
┌─────────────────────────────────────┐
│      接收任务                        │
└─────────────┬───────────────────────┘
              │
              ▼
┌─────────────────────────────────────┐
│  Step 1: 检查任务类型                │
│  是否为强制类型？                    │
└─────────────┬───────────────────────┘
              │
         是   │   否
      ┌───────┴───────┐
      ▼               ▼
┌──────────┐   ┌──────────────┐
│ 使用强制  │   │ Step 2: 估算 │
│ 模型     │   │ 任务规模     │
└──────────┘   └──────┬───────┘
                      │
                      ▼
               ┌──────────────┐
               │ Step 3: 应用 │
               │ 规模映射     │
               └──────┬───────┘
                      │
                      ▼
               ┌──────────────┐
               │ Step 4: 考虑 │
               │ 阶段基础模型  │
               └──────┬───────┘
                      │
                      ▼
               ┌──────────────┐
               │ 返回最终模型  │
               └──────────────┘
```

### 决策示例

**示例 1: 简单任务**
```
任务: 创建 User 数据模型
规模: 预估 30 行代码，1 个文件
类型: 基础代码生成

→ 层级 3 识别为"基础代码生成"
→ 强制使用 Haiku
```

**示例 2: 常规开发**
```
任务: 实现用户登录接口
规模: 预估 120 行代码，2 个文件
类型: 复杂编码

→ 层级 3 识别为"复杂编码"
→ 强制使用 Sonnet
```

**示例 3: 关键决策**
```
任务: 设计系统架构
规模: 涉及多个模块
类型: 架构决策

→ 层级 3 识别为"架构决策"
→ 强制使用 Opus
```

**示例 4: 大型开发任务**
```
任务: 实现完整的用户认证系统
规模: 预估 600 行代码，8 个文件
类型: 一般开发

→ 层级 2 规模为 XL
→ 使用 Opus
```

---

## 实际应用

### 在开发阶段 (/dev)

```
💻 [开发者] 任务分配

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

## 任务: F1 - 用户注册

### 自动模型选择

分析中...

- 任务类型: 复杂编码
- 预估代码: 150 行
- 涉及文件: 3 个
- 复杂度: 中等

→ 选择模型: **Sonnet**
→ 预估成本: $$

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

[1] ✅ 确认使用 Sonnet
[2] 🔄 手动调整模型
[3] 📊 查看选择理由
```

### 在任务分割 (/split)

```
🔄 任务分割 + 模型分配

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

原任务: 实现用户认证系统 (预估 600 行)

## 分割后的子任务

| ID | 子任务 | 规模 | 行数 | 模型 | 成本 |
|----|--------|------|------|------|------|
| T1 | User 模型 | S | 30 | **Haiku** | $ |
| T2 | 注册接口 | M | 120 | Sonnet | $$ |
| T3 | 登录接口 | M | 100 | Sonnet | $$ |
| T4 | JWT 中间件 | M | 80 | Sonnet | $$ |
| T5 | 权限验证 | S | 40 | **Haiku** | $ |

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

总成本对比:
- 单一模型 (Opus): $$$$$
- 智能分配: $ + $$ × 3 + $ = $$$ (节省 40%)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

---

## 手动调整

如果自动选择不合适，可以手动调整：

```bash
# 查看当前任务的模型选择
/project-optimizer:model-selection --current

# 手动指定模型
/project-optimizer:model-selection --set haiku
/project-optimizer:model-selection --set sonnet
/project-optimizer:model-selection --set opus

# 查看成本估算
/project-optimizer:model-selection --cost-estimate
```

### 调整示例

```
📋 当前任务模型

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

任务: F3 - 核心功能实现
自动选择: Sonnet
原因: 规模 M (150 行)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

是否需要调整？

[1] ✅ 保持 Sonnet
[2] ⬇️ 降级到 Haiku (降低成本)
[3] ⬆️ 升级到 Opus (提高质量)
[4] 📊 查看成本对比
```

---

## 成本优化统计

```
📊 模型使用统计

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

项目: 电商网站
阶段: 开发阶段

## 模型分布

| 模型 | 任务数 | 代码行数 | 成本 |
|------|--------|----------|------|
| Haiku | 15 (30%) | 450 行 | $$$ |
| Sonnet | 30 (60%) | 4200 行 | $$$$$$ |
| Opus | 5 (10%) | 1500 行 | $$$ |

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

## 成本对比

全部 Opus: $$$$$$$$$$$ (11 个 $)
智能分配: $$$$$$$$$$ (12 个 $)
**节省**: ~~18%~~

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

---

## 配置

可以在 `.claude/PROJECT_STATE.json` 中配置模型选择策略：

```json
{
  "modelSelection": {
    "enabled": true,
    "strategy": "auto",
    "preferences": {
      "costOptimization": true,
      "qualityThreshold": "medium",
      "allowDowngrade": false
    },
    "overrides": {
      "security": "opus",
      "architecture": "opus",
      "simple_crud": "haiku"
    }
  }
}
```

### 配置说明

| 参数 | 说明 | 默认值 |
|------|------|--------|
| `enabled` | 是否启用自动选择 | `true` |
| `strategy` | 选择策略 (`auto`/`conservative`/`aggressive`) | `auto` |
| `costOptimization` | 优先考虑成本 | `true` |
| `qualityThreshold` | 质量阈值 | `medium` |
| `allowDowngrade` | 允许降级 | `false` |
| `overrides` | 任务类型强制模型 | `{}` |

---

## 注意事项

1. **质量优先** - 关键任务不会为了节省成本而降级模型
2. **动态调整** - 如果任务失败，会自动升级到更强模型重试
3. **成本感知** - 系统会实时显示成本估算
4. **可审计** - 所有模型选择决策都会记录

---

## 相关命令

- `/project-optimizer:dev` - 开发阶段（自动模型选择）
- `/project-optimizer:split` - 任务分割（自动模型分配）
- `/project-optimizer:agents` - Agent 管理（查看模型配置）
- `/project-optimizer:status` - 查看当前模型使用情况
